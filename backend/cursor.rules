# Cursor and Code Rules

## 1. User Experience Rules
- Always focus on input fields automatically when they appear
- Minimize required mouse clicks
- Keep the interface responsive and snappy
- Provide clear visual feedback for all actions
- Remember user preferences where possible

## 2. Code Simplicity Rules
- Use the simplest viable code solution
- Prioritize readability over optimization
- Each line of code should have a clear purpose
- Comment complex logic, but let clear code speak for itself
- Use descriptive variable names over comments where possible
- Keep functions focused and single-purpose
- Avoid premature optimization
- Use standard library solutions over custom implementations
- Break complex operations into simple, clear steps

## 3. Implementation Guidelines
- Auto-focus on text inputs when they appear
- Use consistent keyboard navigation patterns
- Maintain state only when necessary
- Handle errors gracefully with clear messages
- Test with keyboard-only navigation

## 4. Development Workflow Rules
- Always use ./start.sh to run the application - it properly sets up both frontend and backend services
- Never start services manually unless debugging specific components
- Follow the proper shutdown procedure using Ctrl+C to ensure all processes are cleaned up
- Check the logs directory for any issues if services fail to start

## 5. API Configuration Rules
- ALWAYS use relative paths for API endpoints (e.g., '/api/start' not 'http://localhost:5001/api/start')
- NEVER hardcode port numbers in API calls
- ALWAYS use the Vite proxy configuration for API requests
- ALWAYS test both mock and real API modes after configuration changes
- When updating API-related code, verify:
  1. Vite proxy configuration points to correct backend port (5001)
  2. API base URL is set to '/api'
  3. Session handling is properly configured
  4. Error handling includes fallback to mock mode

## 6. Port Management Rules
- Frontend MUST run on port 3000
- Backend MUST run on port 5001
- NEVER mix frontend and backend ports in API calls
- ALWAYS use the proxy configuration in vite.config.js
- Port configuration checklist:
  1. Vite config: frontend port 3000
  2. Vite proxy: backend target http://localhost:5001
  3. API service: base URL '/api' only
  4. Backend: listening on port 5001

## 7. Session Management Rules
- ALWAYS implement graceful fallback to mock mode
- ALWAYS handle session initialization errors
- ALWAYS clear invalid sessions
- Session handling checklist:
  1. Check session existence before API calls
  2. Implement mock session fallback
  3. Clear session on authentication errors
  4. Maintain session consistency across page reloads

## 8. Error Prevention Checklist
Before committing API-related changes:
- [ ] Verify Vite proxy configuration
- [ ] Test API endpoints with backend running
- [ ] Test API endpoints with backend stopped (mock mode)
- [ ] Verify session handling
- [ ] Check port configurations
- [ ] Ensure error handling is in place
- [ ] Test both development and production builds

## 9. Common Issues Prevention
Known issues and their prevention:
1. Wrong Port Issue:
   - Symptom: 500 errors on API calls to port 3000
   - Prevention: Always use relative paths and proxy
   - Fix: Check vite.config.js proxy settings

2. Session Initialization Failure:
   - Symptom: Cannot start new session
   - Prevention: Implement mock fallback
   - Fix: Verify session handling in api.js

3. API Connection Issues:
   - Symptom: Cannot connect to backend
   - Prevention: Use start.sh script
   - Fix: Check backend logs and port configuration

## 10. Testing Requirements
Before deploying any API changes:
1. Test with backend running
2. Test with backend stopped
3. Test session initialization
4. Test error handling
5. Verify proxy configuration
6. Check port settings
7. Validate mock mode functionality

# File and Directory Management Rules

## Directory Structure Guidelines
```
backend/
├── app/                    # Core application code
│   ├── routes/            # API route handlers
│   ├── services/          # Business logic and external services
│   ├── models/            # Data models and schemas
│   └── utils/             # Utility functions and helpers
├── config/                # Configuration files
├── tests/                 # Test files
└── scripts/               # Utility scripts
```

## File Creation Protocol
1. EVALUATE EXISTING FILES:
   - Before creating new files, check if similar functionality exists
   - Search for related files using semantic search or grep
   - Consider extending existing files instead of creating new ones

2. LOCATION DETERMINATION:
   - New files MUST be placed in appropriate directories based on their purpose:
     * Routes -> app/routes/
     * Services -> app/services/
     * Models -> app/models/
     * Utilities -> app/utils/
   - DO NOT create files in the root directory unless they are:
     * Configuration files
     * Entry point files
     * Documentation files

3. FILE NAMING CONVENTIONS:
   - Use lowercase with underscores
   - Be descriptive but concise
   - Include purpose in name (e.g., user_service.py, auth_routes.py)
   - Test files should mirror source files with _test suffix

4. CREATION CHECKLIST:
   Before creating a new file:
   [ ] Verify similar file doesn't exist
   [ ] Confirm appropriate directory exists
   [ ] Check naming follows conventions
   [ ] Ensure __init__.py exists in directory
   [ ] Update relevant imports in dependent files

5. DIRECTORY CREATION RULES:
   - New directories MUST:
     * Have a clear, single responsibility
     * Include an __init__.py file
     * Follow existing structure patterns
     * Be documented in this rules file

6. REFACTORING GUIDELINES:
   - When moving files:
     * Update all import statements
     * Maintain module hierarchy
     * Update documentation
     * Test all affected components

7. PREVENTION CHECKLIST:
   Before implementing changes:
   [ ] Is this a new feature or extension of existing one?
   [ ] Can existing files be modified instead?
   [ ] Will this create circular dependencies?
   [ ] Does it follow the established structure?
   [ ] Are all necessary __init__.py files in place?

## Common Mistakes Prevention
1. DO NOT:
   - Create files without checking existing ones
   - Place business logic in route handlers
   - Mix concerns across directories
   - Create new directories without clear purpose
   - Skip __init__.py files

2. ALWAYS:
   - Follow the directory structure
   - Use semantic naming
   - Update documentation
   - Consider dependencies
   - Test after moving files

## Implementation Examples
GOOD:
```python
# New authentication service
backend/app/services/auth_service.py

# New user routes
backend/app/routes/user_routes.py
```

BAD:
```python
# Don't create in root
backend/auth.py

# Don't mix concerns
backend/app/routes/user_service.py
```

## Maintenance Rules
1. Regular cleanup:
   - Remove unused files
   - Consolidate similar functionality
   - Update documentation
   - Verify import statements

2. Documentation:
   - Update this rules file when adding new directories
   - Document directory purpose in README
   - Keep file headers current
   - Document dependencies

## Emergency Procedures
If incorrect file placement is detected:
1. Document current location and dependencies
2. Create proper directory if needed
3. Move file to correct location
4. Update all imports
5. Test affected components
6. Update documentation

Remember: Structure is not just about organization; it's about maintainability and scalability. 